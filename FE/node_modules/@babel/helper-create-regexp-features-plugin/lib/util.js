"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canSkipRegexpu = canSkipRegexpu;
exports.generateRegexpuOptions = generateRegexpuOptions;
exports.transformFlags = transformFlags;
<<<<<<< HEAD
var _features = require("./features");
=======

var _features = require("./features");

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
function generateRegexpuOptions(pattern, toTransform) {
  const feat = (name, ok = "transform") => {
    return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? ok : false;
  };
<<<<<<< HEAD
  const featDuplicateNamedGroups = () => {
    if (!feat("duplicateNamedCaptureGroups")) return false;

    const regex = /\(\?<([^>]+)>/g;
    const seen = new Set();
    for (let match; match = regex.exec(pattern); seen.add(match[1])) {
      if (seen.has(match[1])) return "transform";
    }
    return false;
  };
=======

  const featDuplicateNamedGroups = () => {
    if (!feat("duplicateNamedCaptureGroups")) return false;
    const regex = /\(\?<([^>]+)>/g;
    const seen = new Set();

    for (let match; match = regex.exec(pattern); seen.add(match[1])) {
      if (seen.has(match[1])) return "transform";
    }

    return false;
  };

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
  return {
    unicodeFlag: feat("unicodeFlag"),
    unicodeSetsFlag: feat("unicodeSetsFlag") || feat("unicodeSetsFlag_syntax", "parse"),
    dotAllFlag: feat("dotAllFlag"),
    unicodePropertyEscapes: feat("unicodePropertyEscape"),
    namedGroups: feat("namedCaptureGroups") || featDuplicateNamedGroups(),
    onNamedGroup: () => {}
  };
}
<<<<<<< HEAD
=======

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
function canSkipRegexpu(node, options) {
  const {
    flags,
    pattern
  } = node;
<<<<<<< HEAD
  if (flags.includes("v")) {
    if (options.unicodeSetsFlag === "transform") return false;
  }
  if (flags.includes("u")) {
    if (options.unicodeFlag === "transform") return false;
=======

  if (flags.includes("v")) {
    if (options.unicodeSetsFlag === "transform") return false;
  }

  if (flags.includes("u")) {
    if (options.unicodeFlag === "transform") return false;

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    if (options.unicodePropertyEscapes === "transform" && /\\[pP]{/.test(pattern)) {
      return false;
    }
  }
<<<<<<< HEAD
  if (flags.includes("s")) {
    if (options.dotAllFlag === "transform") return false;
  }
  if (options.namedGroups === "transform" && /\(\?<(?![=!])/.test(pattern)) {
    return false;
  }
  return true;
}
=======

  if (flags.includes("s")) {
    if (options.dotAllFlag === "transform") return false;
  }

  if (options.namedGroups === "transform" && /\(\?<(?![=!])/.test(pattern)) {
    return false;
  }

  return true;
}

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
function transformFlags(regexpuOptions, flags) {
  if (regexpuOptions.unicodeSetsFlag === "transform") {
    flags = flags.replace("v", "u");
  }
<<<<<<< HEAD
  if (regexpuOptions.unicodeFlag === "transform") {
    flags = flags.replace("u", "");
  }
  if (regexpuOptions.dotAllFlag === "transform") {
    flags = flags.replace("s", "");
  }
=======

  if (regexpuOptions.unicodeFlag === "transform") {
    flags = flags.replace("u", "");
  }

  if (regexpuOptions.dotAllFlag === "transform") {
    flags = flags.replace("s", "");
  }

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
  return flags;
}

//# sourceMappingURL=util.js.map
