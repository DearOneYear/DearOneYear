"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

exports.default = void 0;

var _ContainerBase = require("../ContainerBase");

class PriorityQueue extends _ContainerBase.Base {
<<<<<<< HEAD
    constructor(t = [], s = function(t, s) {
        if (t > s) return -1;
        if (t < s) return 1;
        return 0;
    }, i = true) {
        super();
        this.v = s;
        if (Array.isArray(t)) {
            this.C = i ? [ ...t ] : t;
        } else {
            this.C = [];
            const s = this;
            t.forEach((function(t) {
                s.C.push(t);
            }));
        }
        this.i = this.C.length;
        const e = this.i >> 1;
        for (let t = this.i - 1 >> 1; t >= 0; --t) {
            this.k(t, e);
        }
    }
    m(t) {
        const s = this.C[t];
        while (t > 0) {
            const i = t - 1 >> 1;
            const e = this.C[i];
            if (this.v(e, s) <= 0) break;
            this.C[t] = e;
            t = i;
        }
        this.C[t] = s;
    }
    k(t, s) {
        const i = this.C[t];
        while (t < s) {
            let s = t << 1 | 1;
            const e = s + 1;
            let h = this.C[s];
            if (e < this.i && this.v(h, this.C[e]) > 0) {
                s = e;
                h = this.C[e];
            }
            if (this.v(h, i) >= 0) break;
            this.C[t] = h;
            t = s;
        }
        this.C[t] = i;
    }
    clear() {
        this.i = 0;
        this.C.length = 0;
    }
    push(t) {
        this.C.push(t);
        this.m(this.i);
        this.i += 1;
    }
    pop() {
        if (this.i === 0) return;
        const t = this.C[0];
        const s = this.C.pop();
        this.i -= 1;
        if (this.i) {
            this.C[0] = s;
            this.k(0, this.i >> 1);
        }
        return t;
    }
    top() {
        return this.C[0];
    }
    find(t) {
        return this.C.indexOf(t) >= 0;
    }
    remove(t) {
        const s = this.C.indexOf(t);
        if (s < 0) return false;
        if (s === 0) {
            this.pop();
        } else if (s === this.i - 1) {
            this.C.pop();
            this.i -= 1;
        } else {
            this.C.splice(s, 1, this.C.pop());
            this.i -= 1;
            this.m(s);
            this.k(s, this.i >> 1);
=======
    constructor(t = [], s = ((t, s) => {
        if (t > s) return -1;
        if (t < s) return 1;
        return 0;
    }), i = true) {
        super();
        this.p = s;
        if (Array.isArray(t)) {
            this._ = i ? [ ...t ] : t;
        } else {
            this._ = [];
            t.forEach((t => this._.push(t)));
        }
        this.o = this._.length;
        const e = this.o >> 1;
        for (let t = this.o - 1 >> 1; t >= 0; --t) {
            this.v(t, e);
        }
    }
    B(t) {
        const s = this._[t];
        while (t > 0) {
            const i = t - 1 >> 1;
            const e = this._[i];
            if (this.p(e, s) <= 0) break;
            this._[t] = e;
            t = i;
        }
        this._[t] = s;
    }
    v(t, s) {
        const i = this._[t];
        while (t < s) {
            let s = t << 1 | 1;
            const e = s + 1;
            let h = this._[s];
            if (e < this.o && this.p(h, this._[e]) > 0) {
                s = e;
                h = this._[e];
            }
            if (this.p(h, i) >= 0) break;
            this._[t] = h;
            t = s;
        }
        this._[t] = i;
    }
    clear() {
        this.o = 0;
        this._.length = 0;
    }
    push(t) {
        this._.push(t);
        this.B(this.o);
        this.o += 1;
    }
    pop() {
        if (!this.o) return;
        const t = this._.pop();
        this.o -= 1;
        if (this.o) {
            this._[0] = t;
            this.v(0, this.o >> 1);
        }
    }
    top() {
        return this._[0];
    }
    find(t) {
        return this._.indexOf(t) >= 0;
    }
    remove(t) {
        const s = this._.indexOf(t);
        if (s < 0) return false;
        if (s === 0) {
            this.pop();
        } else if (s === this.o - 1) {
            this._.pop();
            this.o -= 1;
        } else {
            this._.splice(s, 1, this._.pop());
            this.o -= 1;
            this.B(s);
            this.v(s, this.o >> 1);
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        }
        return true;
    }
    updateItem(t) {
<<<<<<< HEAD
        const s = this.C.indexOf(t);
        if (s < 0) return false;
        this.m(s);
        this.k(s, this.i >> 1);
        return true;
    }
    toArray() {
        return [ ...this.C ];
=======
        const s = this._.indexOf(t);
        if (s < 0) return false;
        this.B(s);
        this.v(s, this.o >> 1);
        return true;
    }
    toArray() {
        return [ ...this._ ];
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    }
}

var _default = PriorityQueue;

<<<<<<< HEAD
exports.default = _default;
//# sourceMappingURL=PriorityQueue.js.map
=======
exports.default = _default;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
