"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

<<<<<<< HEAD
exports.default = void 0;
=======
exports.default = exports.DequeIterator = void 0;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

var _Base = _interopRequireDefault(require("./Base"));

var _RandomIterator = require("./Base/RandomIterator");

function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

class DequeIterator extends _RandomIterator.RandomIterator {
    copy() {
<<<<<<< HEAD
        return new DequeIterator(this.o, this.D, this.R, this.N, this.iteratorType);
    }
}

class Deque extends _Base.default {
    constructor(t = [], s = 1 << 12) {
        super();
        this.P = 0;
        this.A = 0;
        this.F = 0;
        this.j = 0;
        this.O = 0;
        this.T = [];
        let i;
        if ("size" in t) {
            if (typeof t.size === "number") {
                i = t.size;
            } else {
                i = t.size();
            }
        } else if ("length" in t) {
            i = t.length;
        } else {
            throw new RangeError("Can't get container's size!");
        }
        this.V = s;
        this.O = Math.max(Math.ceil(i / this.V), 1);
        for (let t = 0; t < this.O; ++t) {
            this.T.push(new Array(this.V));
        }
        const h = Math.ceil(i / this.V);
        this.P = this.F = (this.O >> 1) - (h >> 1);
        this.A = this.j = this.V - i % this.V >> 1;
        const e = this;
        t.forEach((function(t) {
            e.pushBack(t);
        }));
=======
        return new DequeIterator(this.I, this.D, this.g, this.m, this.iteratorType);
    }
}

exports.DequeIterator = DequeIterator;

class Deque extends _Base.default {
    constructor(t = [], i = 1 << 12) {
        super();
        this.R = 0;
        this.k = 0;
        this.N = 0;
        this.M = 0;
        this.u = 0;
        this.P = [];
        let s;
        if ("size" in t) {
            if (typeof t.size === "number") {
                s = t.size;
            } else {
                s = t.size();
            }
        } else if ("length" in t) {
            s = t.length;
        } else {
            throw new RangeError("Can't get container's size!");
        }
        this.A = i;
        this.u = Math.max(Math.ceil(s / this.A), 1);
        for (let t = 0; t < this.u; ++t) {
            this.P.push(new Array(this.A));
        }
        const h = Math.ceil(s / this.A);
        this.R = this.N = (this.u >> 1) - (h >> 1);
        this.k = this.M = this.A - s % this.A >> 1;
        t.forEach((t => this.pushBack(t)));
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        this.size = this.size.bind(this);
        this.getElementByPos = this.getElementByPos.bind(this);
        this.setElementByPos = this.setElementByPos.bind(this);
    }
<<<<<<< HEAD
    G() {
        const t = [];
        const s = Math.max(this.O >> 1, 1);
        for (let i = 0; i < s; ++i) {
            t[i] = new Array(this.V);
        }
        for (let s = this.P; s < this.O; ++s) {
            t[t.length] = this.T[s];
        }
        for (let s = 0; s < this.F; ++s) {
            t[t.length] = this.T[s];
        }
        t[t.length] = [ ...this.T[this.F] ];
        this.P = s;
        this.F = t.length - 1;
        for (let i = 0; i < s; ++i) {
            t[t.length] = new Array(this.V);
        }
        this.T = t;
        this.O = t.length;
    }
    J(t) {
        const s = this.A + t + 1;
        const i = s % this.V;
        let h = i - 1;
        let e = this.P + (s - i) / this.V;
        if (i === 0) e -= 1;
        e %= this.O;
        if (h < 0) h += this.V;
=======
    h() {
        const t = [];
        const i = Math.max(this.u >> 1, 1);
        for (let s = 0; s < i; ++s) {
            t[s] = new Array(this.A);
        }
        for (let i = this.R; i < this.u; ++i) {
            t[t.length] = this.P[i];
        }
        for (let i = 0; i < this.N; ++i) {
            t[t.length] = this.P[i];
        }
        t[t.length] = [ ...this.P[this.N] ];
        this.R = i;
        this.N = t.length - 1;
        for (let s = 0; s < i; ++s) {
            t[t.length] = new Array(this.A);
        }
        this.P = t;
        this.u = t.length;
    }
    F(t) {
        const i = this.k + t + 1;
        const s = i % this.A;
        let h = s - 1;
        let e = this.R + (i - s) / this.A;
        if (s === 0) e -= 1;
        e %= this.u;
        if (h < 0) h += this.A;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        return {
            curNodeBucketIndex: e,
            curNodePointerIndex: h
        };
    }
    clear() {
<<<<<<< HEAD
        this.T = [ [] ];
        this.O = 1;
        this.P = this.F = this.i = 0;
        this.A = this.j = this.V >> 1;
=======
        this.P = [ [] ];
        this.u = 1;
        this.R = this.N = this.o = 0;
        this.k = this.M = this.A >> 1;
    }
    front() {
        return this.P[this.R][this.k];
    }
    back() {
        return this.P[this.N][this.M];
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    }
    begin() {
        return new DequeIterator(0, this.size, this.getElementByPos, this.setElementByPos);
    }
    end() {
<<<<<<< HEAD
        return new DequeIterator(this.i, this.size, this.getElementByPos, this.setElementByPos);
    }
    rBegin() {
        return new DequeIterator(this.i - 1, this.size, this.getElementByPos, this.setElementByPos, 1);
=======
        return new DequeIterator(this.o, this.size, this.getElementByPos, this.setElementByPos);
    }
    rBegin() {
        return new DequeIterator(this.o - 1, this.size, this.getElementByPos, this.setElementByPos, 1);
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    }
    rEnd() {
        return new DequeIterator(-1, this.size, this.getElementByPos, this.setElementByPos, 1);
    }
<<<<<<< HEAD
    front() {
        return this.T[this.P][this.A];
    }
    back() {
        return this.T[this.F][this.j];
    }
    pushBack(t) {
        if (this.i) {
            if (this.j < this.V - 1) {
                this.j += 1;
            } else if (this.F < this.O - 1) {
                this.F += 1;
                this.j = 0;
            } else {
                this.F = 0;
                this.j = 0;
            }
            if (this.F === this.P && this.j === this.A) this.G();
        }
        this.i += 1;
        this.T[this.F][this.j] = t;
        return this.i;
    }
    popBack() {
        if (this.i === 0) return;
        const t = this.T[this.F][this.j];
        delete this.T[this.F][this.j];
        if (this.i !== 1) {
            if (this.j > 0) {
                this.j -= 1;
            } else if (this.F > 0) {
                this.F -= 1;
                this.j = this.V - 1;
            } else {
                this.F = this.O - 1;
                this.j = this.V - 1;
            }
        }
        this.i -= 1;
        return t;
    }
    pushFront(t) {
        if (this.i) {
            if (this.A > 0) {
                this.A -= 1;
            } else if (this.P > 0) {
                this.P -= 1;
                this.A = this.V - 1;
            } else {
                this.P = this.O - 1;
                this.A = this.V - 1;
            }
            if (this.P === this.F && this.A === this.j) this.G();
        }
        this.i += 1;
        this.T[this.P][this.A] = t;
        return this.i;
    }
    popFront() {
        if (this.i === 0) return;
        const t = this.T[this.P][this.A];
        delete this.T[this.P][this.A];
        if (this.i !== 1) {
            if (this.A < this.V - 1) {
                this.A += 1;
            } else if (this.P < this.O - 1) {
                this.P += 1;
                this.A = 0;
            } else {
                this.P = 0;
                this.A = 0;
            }
        }
        this.i -= 1;
        return t;
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: s, curNodePointerIndex: i} = this.J(t);
        return this.T[s][i];
    }
    setElementByPos(t, s) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: i, curNodePointerIndex: h} = this.J(t);
        this.T[i][h] = s;
    }
    insert(t, s, i = 1) {
        if (t < 0 || t > this.i) {
            throw new RangeError;
        }
        if (t === 0) {
            while (i--) this.pushFront(s);
        } else if (t === this.i) {
            while (i--) this.pushBack(s);
        } else {
            const h = [];
            for (let s = t; s < this.i; ++s) {
                h.push(this.getElementByPos(s));
            }
            this.cut(t - 1);
            for (let t = 0; t < i; ++t) this.pushBack(s);
            for (let t = 0; t < h.length; ++t) this.pushBack(h[t]);
        }
        return this.i;
=======
    pushBack(t) {
        if (this.o) {
            if (this.M < this.A - 1) {
                this.M += 1;
            } else if (this.N < this.u - 1) {
                this.N += 1;
                this.M = 0;
            } else {
                this.N = 0;
                this.M = 0;
            }
            if (this.N === this.R && this.M === this.k) this.h();
        }
        this.o += 1;
        this.P[this.N][this.M] = t;
    }
    popBack() {
        if (!this.o) return;
        this.P[this.N][this.M] = undefined;
        if (this.o !== 1) {
            if (this.M > 0) {
                this.M -= 1;
            } else if (this.N > 0) {
                this.N -= 1;
                this.M = this.A - 1;
            } else {
                this.N = this.u - 1;
                this.M = this.A - 1;
            }
        }
        this.o -= 1;
    }
    pushFront(t) {
        if (this.o) {
            if (this.k > 0) {
                this.k -= 1;
            } else if (this.R > 0) {
                this.R -= 1;
                this.k = this.A - 1;
            } else {
                this.R = this.u - 1;
                this.k = this.A - 1;
            }
            if (this.R === this.N && this.k === this.M) this.h();
        }
        this.o += 1;
        this.P[this.R][this.k] = t;
    }
    popFront() {
        if (!this.o) return;
        this.P[this.R][this.k] = undefined;
        if (this.o !== 1) {
            if (this.k < this.A - 1) {
                this.k += 1;
            } else if (this.R < this.u - 1) {
                this.R += 1;
                this.k = 0;
            } else {
                this.R = 0;
                this.k = 0;
            }
        }
        this.o -= 1;
    }
    forEach(t) {
        for (let i = 0; i < this.o; ++i) {
            t(this.getElementByPos(i), i);
        }
    }
    getElementByPos(t) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: i, curNodePointerIndex: s} = this.F(t);
        return this.P[i][s];
    }
    setElementByPos(t, i) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        const {curNodeBucketIndex: s, curNodePointerIndex: h} = this.F(t);
        this.P[s][h] = i;
    }
    insert(t, i, s = 1) {
        if (t < 0 || t > this.o) {
            throw new RangeError;
        }
        if (t === 0) {
            while (s--) this.pushFront(i);
        } else if (t === this.o) {
            while (s--) this.pushBack(i);
        } else {
            const h = [];
            for (let i = t; i < this.o; ++i) {
                h.push(this.getElementByPos(i));
            }
            this.cut(t - 1);
            for (let t = 0; t < s; ++t) this.pushBack(i);
            for (let t = 0; t < h.length; ++t) this.pushBack(h[t]);
        }
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    }
    cut(t) {
        if (t < 0) {
            this.clear();
<<<<<<< HEAD
            return 0;
        }
        const {curNodeBucketIndex: s, curNodePointerIndex: i} = this.J(t);
        this.F = s;
        this.j = i;
        this.i = t + 1;
        return this.i;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        if (t === 0) this.popFront(); else if (t === this.i - 1) this.popBack(); else {
            const s = [];
            for (let i = t + 1; i < this.i; ++i) {
                s.push(this.getElementByPos(i));
            }
            this.cut(t);
            this.popBack();
            const i = this;
            s.forEach((function(t) {
                i.pushBack(t);
            }));
        }
        return this.i;
    }
    eraseElementByValue(t) {
        if (this.i === 0) return 0;
        const s = [];
        for (let i = 0; i < this.i; ++i) {
            const h = this.getElementByPos(i);
            if (h !== t) s.push(h);
        }
        const i = s.length;
        for (let t = 0; t < i; ++t) this.setElementByPos(t, s[t]);
        return this.cut(i - 1);
    }
    eraseElementByIterator(t) {
        const s = t.o;
        this.eraseElementByPos(s);
=======
            return;
        }
        const {curNodeBucketIndex: i, curNodePointerIndex: s} = this.F(t);
        this.N = i;
        this.M = s;
        this.o = t + 1;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        if (t === 0) this.popFront(); else if (t === this.o - 1) this.popBack(); else {
            const i = [];
            for (let s = t + 1; s < this.o; ++s) {
                i.push(this.getElementByPos(s));
            }
            this.cut(t);
            this.popBack();
            i.forEach((t => this.pushBack(t)));
        }
    }
    eraseElementByValue(t) {
        if (!this.o) return;
        const i = [];
        for (let s = 0; s < this.o; ++s) {
            const h = this.getElementByPos(s);
            if (h !== t) i.push(h);
        }
        const s = i.length;
        for (let t = 0; t < s; ++t) this.setElementByPos(t, i[t]);
        this.cut(s - 1);
    }
    eraseElementByIterator(t) {
        const i = t.I;
        this.eraseElementByPos(i);
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        t = t.next();
        return t;
    }
    find(t) {
<<<<<<< HEAD
        for (let s = 0; s < this.i; ++s) {
            if (this.getElementByPos(s) === t) {
                return new DequeIterator(s, this.size, this.getElementByPos, this.setElementByPos);
=======
        for (let i = 0; i < this.o; ++i) {
            if (this.getElementByPos(i) === t) {
                return new DequeIterator(i, this.size, this.getElementByPos, this.setElementByPos);
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            }
        }
        return this.end();
    }
    reverse() {
        let t = 0;
<<<<<<< HEAD
        let s = this.i - 1;
        while (t < s) {
            const i = this.getElementByPos(t);
            this.setElementByPos(t, this.getElementByPos(s));
            this.setElementByPos(s, i);
            t += 1;
            s -= 1;
        }
    }
    unique() {
        if (this.i <= 1) {
            return this.i;
        }
        let t = 1;
        let s = this.getElementByPos(0);
        for (let i = 1; i < this.i; ++i) {
            const h = this.getElementByPos(i);
            if (h !== s) {
                s = h;
                this.setElementByPos(t++, h);
            }
        }
        while (this.i > t) this.popBack();
        return this.i;
    }
    sort(t) {
        const s = [];
        for (let t = 0; t < this.i; ++t) {
            s.push(this.getElementByPos(t));
        }
        s.sort(t);
        for (let t = 0; t < this.i; ++t) this.setElementByPos(t, s[t]);
    }
    shrinkToFit() {
        if (this.i === 0) return;
        const t = [];
        this.forEach((function(s) {
            t.push(s);
        }));
        this.O = Math.max(Math.ceil(this.i / this.V), 1);
        this.i = this.P = this.F = this.A = this.j = 0;
        this.T = [];
        for (let t = 0; t < this.O; ++t) {
            this.T.push(new Array(this.V));
        }
        for (let s = 0; s < t.length; ++s) this.pushBack(t[s]);
    }
    forEach(t) {
        for (let s = 0; s < this.i; ++s) {
            t(this.getElementByPos(s), s, this);
        }
    }
    [Symbol.iterator]() {
        return function*() {
            for (let t = 0; t < this.i; ++t) {
=======
        let i = this.o - 1;
        while (t < i) {
            const s = this.getElementByPos(t);
            this.setElementByPos(t, this.getElementByPos(i));
            this.setElementByPos(i, s);
            t += 1;
            i -= 1;
        }
    }
    unique() {
        if (this.o <= 1) return;
        let t = 1;
        let i = this.getElementByPos(0);
        for (let s = 1; s < this.o; ++s) {
            const h = this.getElementByPos(s);
            if (h !== i) {
                i = h;
                this.setElementByPos(t++, h);
            }
        }
        while (this.o > t) this.popBack();
    }
    sort(t) {
        const i = [];
        for (let t = 0; t < this.o; ++t) {
            i.push(this.getElementByPos(t));
        }
        i.sort(t);
        for (let t = 0; t < this.o; ++t) this.setElementByPos(t, i[t]);
    }
    shrinkToFit() {
        if (!this.o) return;
        const t = [];
        this.forEach((i => t.push(i)));
        this.u = Math.max(Math.ceil(this.o / this.A), 1);
        this.o = this.R = this.N = this.k = this.M = 0;
        this.P = [];
        for (let t = 0; t < this.u; ++t) {
            this.P.push(new Array(this.A));
        }
        for (let i = 0; i < t.length; ++i) this.pushBack(t[i]);
    }
    [Symbol.iterator]() {
        return function*() {
            for (let t = 0; t < this.o; ++t) {
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                yield this.getElementByPos(t);
            }
        }.bind(this)();
    }
}

var _default = Deque;

<<<<<<< HEAD
exports.default = _default;
//# sourceMappingURL=Deque.js.map
=======
exports.default = _default;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
