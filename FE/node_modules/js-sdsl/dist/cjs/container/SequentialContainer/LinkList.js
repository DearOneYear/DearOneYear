"use strict";

Object.defineProperty(exports, "t", {
    value: true
});

<<<<<<< HEAD
exports.default = void 0;
=======
exports.default = exports.LinkNode = exports.LinkListIterator = void 0;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

var _Base = _interopRequireDefault(require("./Base"));

var _ContainerBase = require("../ContainerBase");

<<<<<<< HEAD
var _throwError = require("../../utils/throwError");

=======
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
function _interopRequireDefault(t) {
    return t && t.t ? t : {
        default: t
    };
}

<<<<<<< HEAD
class LinkListIterator extends _ContainerBase.ContainerIterator {
    constructor(t, i, s) {
        super(s);
        this.o = t;
        this.h = i;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.o.L === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
=======
class LinkNode {
    constructor(t) {
        this.L = undefined;
        this.j = undefined;
        this.O = undefined;
        this.L = t;
    }
}

exports.LinkNode = LinkNode;

class LinkListIterator extends _ContainerBase.ContainerIterator {
    constructor(t, i, s) {
        super(s);
        this.I = t;
        this.S = i;
        if (this.iteratorType === 0) {
            this.pre = function() {
                if (this.I.j === this.S) {
                    throw new RangeError("LinkList iterator access denied!");
                }
                this.I = this.I.j;
                return this;
            };
            this.next = function() {
                if (this.I === this.S) {
                    throw new RangeError("LinkList iterator access denied!");
                }
                this.I = this.I.O;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                return this;
            };
        } else {
            this.pre = function() {
<<<<<<< HEAD
                if (this.o.B === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.B;
                return this;
            };
            this.next = function() {
                if (this.o === this.h) {
                    (0, _throwError.throwIteratorAccessError)();
                }
                this.o = this.o.L;
=======
                if (this.I.O === this.S) {
                    throw new RangeError("LinkList iterator access denied!");
                }
                this.I = this.I.O;
                return this;
            };
            this.next = function() {
                if (this.I === this.S) {
                    throw new RangeError("LinkList iterator access denied!");
                }
                this.I = this.I.j;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                return this;
            };
        }
    }
    get pointer() {
<<<<<<< HEAD
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        return this.o.l;
    }
    set pointer(t) {
        if (this.o === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        this.o.l = t;
    }
    copy() {
        return new LinkListIterator(this.o, this.h, this.iteratorType);
    }
}

class LinkList extends _Base.default {
    constructor(t = []) {
        super();
        this.h = {};
        this.p = this._ = this.h.L = this.h.B = this.h;
        const i = this;
        t.forEach((function(t) {
            i.pushBack(t);
        }));
    }
    K(t) {
        const {L: i, B: s} = t;
        i.B = s;
        s.L = i;
        if (t === this.p) {
            this.p = s;
        }
        if (t === this._) {
            this._ = i;
        }
        this.i -= 1;
    }
    U(t, i) {
        const s = i.B;
        const r = {
            l: t,
            L: i,
            B: s
        };
        i.B = r;
        s.L = r;
        if (i === this.h) {
            this.p = r;
        }
        if (s === this.h) {
            this._ = r;
        }
        this.i += 1;
    }
    clear() {
        this.i = 0;
        this.p = this._ = this.h.L = this.h.B = this.h;
    }
    begin() {
        return new LinkListIterator(this.p, this.h);
    }
    end() {
        return new LinkListIterator(this.h, this.h);
    }
    rBegin() {
        return new LinkListIterator(this._, this.h, 1);
    }
    rEnd() {
        return new LinkListIterator(this.h, this.h, 1);
    }
    front() {
        return this.p.l;
    }
    back() {
        return this._.l;
    }
    getElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let i = this.p;
        while (t--) {
            i = i.B;
        }
        return i.l;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let i = this.p;
        while (t--) {
            i = i.B;
        }
        this.K(i);
        return this.i;
    }
    eraseElementByValue(t) {
        let i = this.p;
        while (i !== this.h) {
            if (i.l === t) {
                this.K(i);
            }
            i = i.B;
        }
        return this.i;
    }
    eraseElementByIterator(t) {
        const i = t.o;
        if (i === this.h) {
            (0, _throwError.throwIteratorAccessError)();
        }
        t = t.next();
        this.K(i);
        return t;
    }
    pushBack(t) {
        this.U(t, this._);
        return this.i;
    }
    popBack() {
        if (this.i === 0) return;
        const t = this._.l;
        this.K(this._);
        return t;
    }
    pushFront(t) {
        this.U(t, this.h);
        return this.i;
    }
    popFront() {
        if (this.i === 0) return;
        const t = this.p.l;
        this.K(this.p);
        return t;
    }
    setElementByPos(t, i) {
        if (t < 0 || t > this.i - 1) {
            throw new RangeError;
        }
        let s = this.p;
        while (t--) {
            s = s.B;
        }
        s.l = i;
    }
    insert(t, i, s = 1) {
        if (t < 0 || t > this.i) {
            throw new RangeError;
        }
        if (s <= 0) return this.i;
        if (t === 0) {
            while (s--) this.pushFront(i);
        } else if (t === this.i) {
            while (s--) this.pushBack(i);
        } else {
            let r = this.p;
            for (let i = 1; i < t; ++i) {
                r = r.B;
            }
            const e = r.B;
            this.i += s;
            while (s--) {
                r.B = {
                    l: i,
                    L: r
                };
                r.B.L = r;
                r = r.B;
            }
            r.B = e;
            e.L = r;
        }
        return this.i;
    }
    find(t) {
        let i = this.p;
        while (i !== this.h) {
            if (i.l === t) {
                return new LinkListIterator(i, this.h);
            }
            i = i.B;
=======
        if (this.I === this.S) {
            throw new RangeError("LinkList iterator access denied!");
        }
        return this.I.L;
    }
    set pointer(t) {
        if (this.I === this.S) {
            throw new RangeError("LinkList iterator access denied!");
        }
        this.I.L = t;
    }
    equals(t) {
        return this.I === t.I;
    }
    copy() {
        return new LinkListIterator(this.I, this.S, this.iteratorType);
    }
}

exports.LinkListIterator = LinkListIterator;

class LinkList extends _Base.default {
    constructor(t = []) {
        super();
        this.S = new LinkNode;
        this.V = undefined;
        this.G = undefined;
        t.forEach((t => this.pushBack(t)));
    }
    clear() {
        this.o = 0;
        this.V = this.G = undefined;
        this.S.j = this.S.O = undefined;
    }
    begin() {
        return new LinkListIterator(this.V || this.S, this.S);
    }
    end() {
        return new LinkListIterator(this.S, this.S);
    }
    rBegin() {
        return new LinkListIterator(this.G || this.S, this.S, 1);
    }
    rEnd() {
        return new LinkListIterator(this.S, this.S, 1);
    }
    front() {
        return this.V ? this.V.L : undefined;
    }
    back() {
        return this.G ? this.G.L : undefined;
    }
    forEach(t) {
        if (!this.o) return;
        let i = this.V;
        let s = 0;
        while (i !== this.S) {
            t(i.L, s++);
            i = i.O;
        }
    }
    getElementByPos(t) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        let i = this.V;
        while (t--) {
            i = i.O;
        }
        return i.L;
    }
    eraseElementByPos(t) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        if (t === 0) this.popFront(); else if (t === this.o - 1) this.popBack(); else {
            let i = this.V;
            while (t--) {
                i = i.O;
            }
            i = i;
            const s = i.j;
            const e = i.O;
            e.j = s;
            s.O = e;
            this.o -= 1;
        }
    }
    eraseElementByValue(t) {
        while (this.V && this.V.L === t) this.popFront();
        while (this.G && this.G.L === t) this.popBack();
        if (!this.V) return;
        let i = this.V;
        while (i !== this.S) {
            if (i.L === t) {
                const t = i.j;
                const s = i.O;
                s.j = t;
                t.O = s;
                this.o -= 1;
            }
            i = i.O;
        }
    }
    eraseElementByIterator(t) {
        const i = t.I;
        if (i === this.S) {
            throw new RangeError("Invalid iterator");
        }
        t = t.next();
        if (this.V === i) this.popFront(); else if (this.G === i) this.popBack(); else {
            const t = i.j;
            const s = i.O;
            s.j = t;
            t.O = s;
            this.o -= 1;
        }
        return t;
    }
    pushBack(t) {
        this.o += 1;
        const i = new LinkNode(t);
        if (!this.G) {
            this.V = this.G = i;
            this.S.O = this.V;
            this.V.j = this.S;
        } else {
            this.G.O = i;
            i.j = this.G;
            this.G = i;
        }
        this.G.O = this.S;
        this.S.j = this.G;
    }
    popBack() {
        if (!this.G) return;
        this.o -= 1;
        if (this.V === this.G) {
            this.V = this.G = undefined;
            this.S.O = undefined;
        } else {
            this.G = this.G.j;
            this.G.O = this.S;
        }
        this.S.j = this.G;
    }
    setElementByPos(t, i) {
        if (t < 0 || t > this.o - 1) {
            throw new RangeError;
        }
        let s = this.V;
        while (t--) {
            s = s.O;
        }
        s.L = i;
    }
    insert(t, i, s = 1) {
        if (t < 0 || t > this.o) {
            throw new RangeError;
        }
        if (s <= 0) return;
        if (t === 0) {
            while (s--) this.pushFront(i);
        } else if (t === this.o) {
            while (s--) this.pushBack(i);
        } else {
            let e = this.V;
            for (let i = 1; i < t; ++i) {
                e = e.O;
            }
            const h = e.O;
            this.o += s;
            while (s--) {
                e.O = new LinkNode(i);
                e.O.j = e;
                e = e.O;
            }
            e.O = h;
            h.j = e;
        }
    }
    find(t) {
        if (!this.V) return this.end();
        let i = this.V;
        while (i !== this.S) {
            if (i.L === t) {
                return new LinkListIterator(i, this.S);
            }
            i = i.O;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        }
        return this.end();
    }
    reverse() {
<<<<<<< HEAD
        if (this.i <= 1) return;
        let t = this.p;
        let i = this._;
        let s = 0;
        while (s << 1 < this.i) {
            const r = t.l;
            t.l = i.l;
            i.l = r;
            t = t.B;
            i = i.L;
=======
        if (this.o <= 1) return;
        let t = this.V;
        let i = this.G;
        let s = 0;
        while (s << 1 < this.o) {
            const e = t.L;
            t.L = i.L;
            i.L = e;
            t = t.O;
            i = i.j;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            s += 1;
        }
    }
    unique() {
<<<<<<< HEAD
        if (this.i <= 1) {
            return this.i;
        }
        let t = this.p;
        while (t !== this.h) {
            let i = t;
            while (i.B !== this.h && i.l === i.B.l) {
                i = i.B;
                this.i -= 1;
            }
            t.B = i.B;
            t.B.L = t;
            t = t.B;
        }
        return this.i;
    }
    sort(t) {
        if (this.i <= 1) return;
        const i = [];
        this.forEach((function(t) {
            i.push(t);
        }));
        i.sort(t);
        let s = this.p;
        i.forEach((function(t) {
            s.l = t;
            s = s.B;
        }));
    }
    merge(t) {
        const i = this;
        if (this.i === 0) {
            t.forEach((function(t) {
                i.pushBack(t);
            }));
        } else {
            let s = this.p;
            t.forEach((function(t) {
                while (s !== i.h && s.l <= t) {
                    s = s.B;
                }
                i.U(t, s.L);
            }));
        }
        return this.i;
    }
    forEach(t) {
        let i = this.p;
        let s = 0;
        while (i !== this.h) {
            t(i.l, s++, this);
            i = i.B;
        }
    }
    [Symbol.iterator]() {
        return function*() {
            if (this.i === 0) return;
            let t = this.p;
            while (t !== this.h) {
                yield t.l;
                t = t.B;
=======
        if (this.o <= 1) return;
        let t = this.V;
        while (t !== this.S) {
            let i = t;
            while (i.O && i.L === i.O.L) {
                i = i.O;
                this.o -= 1;
            }
            t.O = i.O;
            t.O.j = t;
            t = t.O;
        }
    }
    sort(t) {
        if (this.o <= 1) return;
        const i = [];
        this.forEach((t => i.push(t)));
        i.sort(t);
        let s = this.V;
        i.forEach((t => {
            s.L = t;
            s = s.O;
        }));
    }
    pushFront(t) {
        this.o += 1;
        const i = new LinkNode(t);
        if (!this.V) {
            this.V = this.G = i;
            this.G.O = this.S;
            this.S.j = this.G;
        } else {
            i.O = this.V;
            this.V.j = i;
            this.V = i;
        }
        this.S.O = this.V;
        this.V.j = this.S;
    }
    popFront() {
        if (!this.V) return;
        this.o -= 1;
        if (this.V === this.G) {
            this.V = this.G = undefined;
            this.S.j = this.G;
        } else {
            this.V = this.V.O;
            this.V.j = this.S;
        }
        this.S.O = this.V;
    }
    merge(t) {
        if (!this.V) {
            t.forEach((t => this.pushBack(t)));
            return;
        }
        let i = this.V;
        t.forEach((t => {
            while (i && i !== this.S && i.L <= t) {
                i = i.O;
            }
            if (i === this.S) {
                this.pushBack(t);
                i = this.G;
            } else if (i === this.V) {
                this.pushFront(t);
                i = this.V;
            } else {
                this.o += 1;
                const s = i.j;
                s.O = new LinkNode(t);
                s.O.j = s;
                s.O.O = i;
                i.j = s.O;
            }
        }));
    }
    [Symbol.iterator]() {
        return function*() {
            if (!this.V) return;
            let t = this.V;
            while (t !== this.S) {
                yield t.L;
                t = t.O;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            }
        }.bind(this)();
    }
}

var _default = LinkList;

<<<<<<< HEAD
exports.default = _default;
//# sourceMappingURL=LinkList.js.map
=======
exports.default = _default;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
