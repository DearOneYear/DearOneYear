/**
 * @fileoverview Disallow mixed spaces and tabs for indentation
 * @author Jary Niebur
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
module.exports = {
    meta: {
        type: "layout",

        docs: {
<<<<<<< HEAD
            description: "disallow mixed spaces and tabs for indentation",
            category: "Stylistic Issues",
=======
            description: "Disallow mixed spaces and tabs for indentation",
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            recommended: true,
            url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"
        },

        schema: [
            {
                enum: ["smart-tabs", true, false]
            }
<<<<<<< HEAD
        ]
=======
        ],

        messages: {
            mixedSpacesAndTabs: "Mixed spaces and tabs."
        }
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    },

    create(context) {
        const sourceCode = context.getSourceCode();

        let smartTabs;
<<<<<<< HEAD
        const ignoredLocs = [];
=======
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

        switch (context.options[0]) {
            case true: // Support old syntax, maybe add deprecation warning here
            case "smart-tabs":
                smartTabs = true;
                break;
            default:
                smartTabs = false;
        }

<<<<<<< HEAD
        /**
         * Determines if a given line and column are before a location.
         * @param {Location} loc The location object from an AST node.
         * @param {int} line The line to check.
         * @param {int} column The column to check.
         * @returns {boolean} True if the line and column are before the location, false if not.
         * @private
         */
        function beforeLoc(loc, line, column) {
            if (line < loc.start.line) {
                return true;
            }
            return line === loc.start.line && column < loc.start.column;
        }

        /**
         * Determines if a given line and column are after a location.
         * @param {Location} loc The location object from an AST node.
         * @param {int} line The line to check.
         * @param {int} column The column to check.
         * @returns {boolean} True if the line and column are after the location, false if not.
         * @private
         */
        function afterLoc(loc, line, column) {
            if (line > loc.end.line) {
                return true;
            }
            return line === loc.end.line && column > loc.end.column;
        }

=======
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {

<<<<<<< HEAD
            TemplateElement(node) {
                ignoredLocs.push(node.loc);
            },

            "Program:exit"(node) {
=======
            "Program:exit"(node) {
                const lines = sourceCode.lines,
                    comments = sourceCode.getAllComments(),
                    ignoredCommentLines = new Set();

                // Add all lines except the first ones.
                comments.forEach(comment => {
                    for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {
                        ignoredCommentLines.add(i);
                    }
                });
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

                /*
                 * At least one space followed by a tab
                 * or the reverse before non-tab/-space
                 * characters begin.
                 */
<<<<<<< HEAD
                let regex = /^(?=[\t ]*(\t | \t))/u;
                const lines = sourceCode.lines,
                    comments = sourceCode.getAllComments();

                comments.forEach(comment => {
                    ignoredLocs.push(comment.loc);
                });

                ignoredLocs.sort((first, second) => {
                    if (beforeLoc(first, second.start.line, second.start.column)) {
                        return 1;
                    }

                    if (beforeLoc(second, first.start.line, second.start.column)) {
                        return -1;
                    }

                    return 0;
                });
=======
                let regex = /^(?=( +|\t+))\1(?:\t| )/u;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

                if (smartTabs) {

                    /*
                     * At least one space followed by a tab
                     * before non-tab/-space characters begin.
                     */
<<<<<<< HEAD
                    regex = /^(?=[\t ]* \t)/u;
=======
                    regex = /^(?=(\t*))\1(?=( +))\2\t/u;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                }

                lines.forEach((line, i) => {
                    const match = regex.exec(line);

                    if (match) {
<<<<<<< HEAD
                        const lineNumber = i + 1,
                            column = match.index + 1;

                        for (let j = 0; j < ignoredLocs.length; j++) {
                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
                                continue;
                            }
                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {
                                continue;
                            }

                            return;
                        }

                        context.report({ node, loc: { line: lineNumber, column }, message: "Mixed spaces and tabs." });
                    }
                });
            }

        };

=======
                        const lineNumber = i + 1;
                        const loc = {
                            start: {
                                line: lineNumber,
                                column: match[0].length - 2
                            },
                            end: {
                                line: lineNumber,
                                column: match[0].length
                            }
                        };

                        if (!ignoredCommentLines.has(lineNumber)) {
                            const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));

                            if (!(containingNode && ["Literal", "TemplateElement"].includes(containingNode.type))) {
                                context.report({
                                    node,
                                    loc,
                                    messageId: "mixedSpacesAndTabs"
                                });
                            }
                        }
                    }
                });
            }
        };
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    }
};
