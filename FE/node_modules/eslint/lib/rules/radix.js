/**
 * @fileoverview Rule to flag use of parseInt without a radix argument
 * @author James Allardice
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const MODE_ALWAYS = "always",
    MODE_AS_NEEDED = "as-needed";

<<<<<<< HEAD
=======
const validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
/**
 * Checks whether a given variable is shadowed or not.
 * @param {eslint-scope.Variable} variable A variable to check.
 * @returns {boolean} `true` if the variable is shadowed.
 */
function isShadowed(variable) {
    return variable.defs.length >= 1;
}

/**
 * Checks whether a given node is a MemberExpression of `parseInt` method or not.
 * @param {ASTNode} node A node to check.
 * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`
 *      method.
 */
function isParseIntMethod(node) {
    return (
        node.type === "MemberExpression" &&
        !node.computed &&
        node.property.type === "Identifier" &&
        node.property.name === "parseInt"
    );
}

/**
 * Checks whether a given node is a valid value of radix or not.
 *
 * The following values are invalid.
 *
<<<<<<< HEAD
 * - A literal except numbers.
=======
 * - A literal except integers between 2 and 36.
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
 * - undefined.
 * @param {ASTNode} radix A node of radix to check.
 * @returns {boolean} `true` if the node is valid.
 */
function isValidRadix(radix) {
    return !(
<<<<<<< HEAD
        (radix.type === "Literal" && typeof radix.value !== "number") ||
=======
        (radix.type === "Literal" && !validRadixValues.has(radix.value)) ||
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        (radix.type === "Identifier" && radix.name === "undefined")
    );
}

/**
 * Checks whether a given node is a default value of radix or not.
 * @param {ASTNode} radix A node of radix to check.
 * @returns {boolean} `true` if the node is the literal node of `10`.
 */
function isDefaultRadix(radix) {
    return radix.type === "Literal" && radix.value === 10;
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
            description: "enforce the consistent use of the radix argument when using `parseInt()`",
            category: "Best Practices",
=======
            description: "Enforce the consistent use of the radix argument when using `parseInt()`",
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            recommended: false,
            url: "https://eslint.org/docs/rules/radix"
        },

<<<<<<< HEAD
=======
        hasSuggestions: true,

>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        schema: [
            {
                enum: ["always", "as-needed"]
            }
<<<<<<< HEAD
        ]
=======
        ],

        messages: {
            missingParameters: "Missing parameters.",
            redundantRadix: "Redundant radix parameter.",
            missingRadix: "Missing radix parameter.",
            invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.",
            addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers."
        }
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    },

    create(context) {
        const mode = context.options[0] || MODE_ALWAYS;

        /**
         * Checks the arguments of a given CallExpression node and reports it if it
         * offends this rule.
         * @param {ASTNode} node A CallExpression node to check.
         * @returns {void}
         */
        function checkArguments(node) {
            const args = node.arguments;

            switch (args.length) {
                case 0:
                    context.report({
                        node,
<<<<<<< HEAD
                        message: "Missing parameters."
=======
                        messageId: "missingParameters"
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                    });
                    break;

                case 1:
                    if (mode === MODE_ALWAYS) {
                        context.report({
                            node,
<<<<<<< HEAD
                            message: "Missing radix parameter."
=======
                            messageId: "missingRadix",
                            suggest: [
                                {
                                    messageId: "addRadixParameter10",
                                    fix(fixer) {
                                        const sourceCode = context.getSourceCode();
                                        const tokens = sourceCode.getTokens(node);
                                        const lastToken = tokens[tokens.length - 1]; // Parenthesis.
                                        const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.
                                        const hasTrailingComma = secondToLastToken.type === "Punctuator" && secondToLastToken.value === ",";

                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? " 10," : ", 10");
                                    }
                                }
                            ]
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                        });
                    }
                    break;

                default:
                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
                        context.report({
                            node,
<<<<<<< HEAD
                            message: "Redundant radix parameter."
=======
                            messageId: "redundantRadix"
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                        });
                    } else if (!isValidRadix(args[1])) {
                        context.report({
                            node,
<<<<<<< HEAD
                            message: "Invalid radix parameter."
=======
                            messageId: "invalidRadix"
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                        });
                    }
                    break;
            }
        }

        return {
            "Program:exit"() {
                const scope = context.getScope();
                let variable;

                // Check `parseInt()`
                variable = astUtils.getVariableByName(scope, "parseInt");
<<<<<<< HEAD
                if (!isShadowed(variable)) {
=======
                if (variable && !isShadowed(variable)) {
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                    variable.references.forEach(reference => {
                        const node = reference.identifier;

                        if (astUtils.isCallee(node)) {
                            checkArguments(node.parent);
                        }
                    });
                }

                // Check `Number.parseInt()`
                variable = astUtils.getVariableByName(scope, "Number");
<<<<<<< HEAD
                if (!isShadowed(variable)) {
                    variable.references.forEach(reference => {
                        const node = reference.identifier.parent;

                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {
                            checkArguments(node.parent);
=======
                if (variable && !isShadowed(variable)) {
                    variable.references.forEach(reference => {
                        const node = reference.identifier.parent;
                        const maybeCallee = node.parent.type === "ChainExpression"
                            ? node.parent
                            : node;

                        if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {
                            checkArguments(maybeCallee.parent);
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                        }
                    });
                }
            }
        };
    }
};
