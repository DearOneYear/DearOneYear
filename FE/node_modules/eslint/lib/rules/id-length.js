/**
 * @fileoverview Rule that warns when identifier names are shorter or longer
 * than the values provided in configuration.
 * @author Burak Yigit Kaya aka BYK
 */

"use strict";

//------------------------------------------------------------------------------
<<<<<<< HEAD
// Rule Definition
//------------------------------------------------------------------------------

=======
// Requirements
//------------------------------------------------------------------------------
const GraphemeSplitter = require("grapheme-splitter");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks if the string given as argument is ASCII or not.
 * @param {string} value A string that you want to know if it is ASCII or not.
 * @returns {boolean} `true` if `value` is ASCII string.
 */
function isASCII(value) {
    if (typeof value !== "string") {
        return false;
    }
    return /^[\u0020-\u007f]*$/u.test(value);
}

/** @type {GraphemeSplitter | undefined} */
let splitter;

/**
 * Gets the length of the string. If the string is not in ASCII, counts graphemes.
 * @param {string} value A string that you want to get the length.
 * @returns {number} The length of `value`.
 */
function getStringLength(value) {
    if (isASCII(value)) {
        return value.length;
    }
    if (!splitter) {
        splitter = new GraphemeSplitter();
    }
    return splitter.countGraphemes(value);
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
            description: "enforce minimum and maximum identifier lengths",
            category: "Stylistic Issues",
=======
            description: "Enforce minimum and maximum identifier lengths",
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            recommended: false,
            url: "https://eslint.org/docs/rules/id-length"
        },

        schema: [
            {
                type: "object",
                properties: {
                    min: {
                        type: "integer",
                        default: 2
                    },
                    max: {
                        type: "integer"
                    },
                    exceptions: {
                        type: "array",
                        uniqueItems: true,
                        items: {
                            type: "string"
                        }
                    },
<<<<<<< HEAD
=======
                    exceptionPatterns: {
                        type: "array",
                        uniqueItems: true,
                        items: {
                            type: "string"
                        }
                    },
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                    properties: {
                        enum: ["always", "never"]
                    }
                },
                additionalProperties: false
            }
        ],
        messages: {
            tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
<<<<<<< HEAD
            tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
=======
            tooShortPrivate: "Identifier name '#{{name}}' is too short (< {{min}}).",
            tooLong: "Identifier name '{{name}}' is too long (> {{max}}).",
            tooLongPrivate: "Identifier name #'{{name}}' is too long (> {{max}})."
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
        }
    },

    create(context) {
        const options = context.options[0] || {};
        const minLength = typeof options.min !== "undefined" ? options.min : 2;
        const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
        const properties = options.properties !== "never";
<<<<<<< HEAD
        const exceptions = (options.exceptions ? options.exceptions : [])
            .reduce((obj, item) => {
                obj[item] = true;

                return obj;
            }, {});
=======
        const exceptions = new Set(options.exceptions);
        const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, "u"));
        const reportedNodes = new Set();

        /**
         * Checks if a string matches the provided exception patterns
         * @param {string} name The string to check.
         * @returns {boolean} if the string is a match
         * @private
         */
        function matchesExceptionPattern(name) {
            return exceptionPatterns.some(pattern => pattern.test(name));
        }
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a

        const SUPPORTED_EXPRESSIONS = {
            MemberExpression: properties && function(parent) {
                return !parent.computed && (

                    // regular property assignment
                    (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||

                    // or the last identifier in an ObjectPattern destructuring
                    parent.parent.type === "Property" && parent.parent.value === parent &&
                    parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent)
                );
            },
            AssignmentPattern(parent, node) {
                return parent.left === node;
            },
            VariableDeclarator(parent, node) {
                return parent.id === node;
            },
<<<<<<< HEAD
            Property: properties && function(parent, node) {
                return parent.key === node;
=======
            Property(parent, node) {

                if (parent.parent.type === "ObjectPattern") {
                    const isKeyAndValueSame = parent.value.name === parent.key.name;

                    return (
                        !isKeyAndValueSame && parent.value === node ||
                        isKeyAndValueSame && parent.key === node && properties
                    );
                }
                return properties && !parent.computed && parent.key.name === node.name;
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            },
            ImportDefaultSpecifier: true,
            RestElement: true,
            FunctionExpression: true,
            ArrowFunctionExpression: true,
            ClassDeclaration: true,
            FunctionDeclaration: true,
            MethodDefinition: true,
<<<<<<< HEAD
            CatchClause: true
        };

        return {
            Identifier(node) {
                const name = node.name;
                const parent = node.parent;

                const isShort = name.length < minLength;
                const isLong = name.length > maxLength;

                if (!(isShort || isLong) || exceptions[name]) {
=======
            PropertyDefinition: true,
            CatchClause: true,
            ArrayPattern: true
        };

        return {
            [[
                "Identifier",
                "PrivateIdentifier"
            ]](node) {
                const name = node.name;
                const parent = node.parent;

                const nameLength = getStringLength(name);

                const isShort = nameLength < minLength;
                const isLong = nameLength > maxLength;

                if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                    return; // Nothing to report
                }

                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

<<<<<<< HEAD
                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
                    context.report({
                        node,
                        messageId: isShort ? "tooShort" : "tooLong",
=======
                /*
                 * We used the range instead of the node because it's possible
                 * for the same identifier to be represented by two different
                 * nodes, with the most clear example being shorthand properties:
                 * { foo }
                 * In this case, "foo" is represented by one node for the name
                 * and one for the value. The only way to know they are the same
                 * is to look at the range.
                 */
                if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {
                    reportedNodes.add(node.range.toString());

                    let messageId = isShort ? "tooShort" : "tooLong";

                    if (node.type === "PrivateIdentifier") {
                        messageId += "Private";
                    }

                    context.report({
                        node,
                        messageId,
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                        data: { name, min: minLength, max: maxLength }
                    });
                }
            }
        };
    }
};
