/**
 * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.
 * @author Kai Cataldo
 */

"use strict";

//------------------------------------------------------------------------------
<<<<<<< HEAD
// Rule Definition
//------------------------------------------------------------------------------

=======
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule} */
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
<<<<<<< HEAD
            description: "disallow renaming import, export, and destructured assignments to the same name",
            category: "ECMAScript 6",
=======
            description: "Disallow renaming import, export, and destructured assignments to the same name",
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            recommended: false,
            url: "https://eslint.org/docs/rules/no-useless-rename"
        },

        fixable: "code",

        schema: [
            {
                type: "object",
                properties: {
                    ignoreDestructuring: { type: "boolean", default: false },
                    ignoreImport: { type: "boolean", default: false },
                    ignoreExport: { type: "boolean", default: false }
                },
                additionalProperties: false
            }
<<<<<<< HEAD
        ]
=======
        ],

        messages: {
            unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
        }
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
    },

    create(context) {
        const sourceCode = context.getSourceCode(),
            options = context.options[0] || {},
            ignoreDestructuring = options.ignoreDestructuring === true,
            ignoreImport = options.ignoreImport === true,
            ignoreExport = options.ignoreExport === true;

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Reports error for unnecessarily renamed assignments
         * @param {ASTNode} node node to report
         * @param {ASTNode} initial node with initial name value
<<<<<<< HEAD
         * @param {ASTNode} result node with new name value
         * @param {string} type the type of the offending node
         * @returns {void}
         */
        function reportError(node, initial, result, type) {
=======
         * @param {string} type the type of the offending node
         * @returns {void}
         */
        function reportError(node, initial, type) {
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            const name = initial.type === "Identifier" ? initial.name : initial.value;

            return context.report({
                node,
<<<<<<< HEAD
                message: "{{type}} {{name}} unnecessarily renamed.",
=======
                messageId: "unnecessarilyRenamed",
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                data: {
                    name,
                    type
                },
                fix(fixer) {
<<<<<<< HEAD
                    if (sourceCode.commentsExistBetween(initial, result)) {
                        return null;
                    }

                    const replacementText = result.type === "AssignmentPattern"
                        ? sourceCode.getText(result)
                        : name;

                    return fixer.replaceTextRange([
                        initial.range[0],
                        result.range[1]
                    ], replacementText);
=======
                    const replacementNode = node.type === "Property" ? node.value : node.local;

                    if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {
                        return null;
                    }

                    // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.
                    if (
                        replacementNode.type === "AssignmentPattern" &&
                        astUtils.isParenthesised(sourceCode, replacementNode.left)
                    ) {
                        return null;
                    }

                    return fixer.replaceText(node, sourceCode.getText(replacementNode));
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                }
            });
        }

        /**
         * Checks whether a destructured assignment is unnecessarily renamed
         * @param {ASTNode} node node to check
         * @returns {void}
         */
        function checkDestructured(node) {
            if (ignoreDestructuring) {
                return;
            }

            for (const property of node.properties) {

<<<<<<< HEAD
                /*
                 * TODO: Remove after babel-eslint removes ExperimentalRestProperty
                 * https://github.com/eslint/eslint/issues/12335
                 */
                if (property.type === "ExperimentalRestProperty") {
                    continue;
                }

=======
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                /**
                 * Properties using shorthand syntax and rest elements can not be renamed.
                 * If the property is computed, we have no idea if a rename is useless or not.
                 */
<<<<<<< HEAD
                if (property.shorthand || property.type === "RestElement" || property.computed) {
=======
                if (property.type !== "Property" || property.shorthand || property.computed) {
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                    continue;
                }

                const key = (property.key.type === "Identifier" && property.key.name) || (property.key.type === "Literal" && property.key.value);
                const renamedKey = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;

                if (key === renamedKey) {
<<<<<<< HEAD
                    reportError(property, property.key, property.value, "Destructuring assignment");
=======
                    reportError(property, property.key, "Destructuring assignment");
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
                }
            }
        }

        /**
         * Checks whether an import is unnecessarily renamed
         * @param {ASTNode} node node to check
         * @returns {void}
         */
        function checkImport(node) {
            if (ignoreImport) {
                return;
            }

<<<<<<< HEAD
            if (node.imported.name === node.local.name &&
                    node.imported.range[0] !== node.local.range[0]) {
                reportError(node, node.imported, node.local, "Import");
=======
            if (
                node.imported.range[0] !== node.local.range[0] &&
                astUtils.getModuleExportName(node.imported) === node.local.name
            ) {
                reportError(node, node.imported, "Import");
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            }
        }

        /**
         * Checks whether an export is unnecessarily renamed
         * @param {ASTNode} node node to check
         * @returns {void}
         */
        function checkExport(node) {
            if (ignoreExport) {
                return;
            }

<<<<<<< HEAD
            if (node.local.name === node.exported.name &&
                    node.local.range[0] !== node.exported.range[0]) {
                reportError(node, node.local, node.exported, "Export");
=======
            if (
                node.local.range[0] !== node.exported.range[0] &&
                astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)
            ) {
                reportError(node, node.local, "Export");
>>>>>>> 63b85f7d93ea628752d182d7c05714398f627e7a
            }

        }

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            ObjectPattern: checkDestructured,
            ImportSpecifier: checkImport,
            ExportSpecifier: checkExport
        };
    }
};
